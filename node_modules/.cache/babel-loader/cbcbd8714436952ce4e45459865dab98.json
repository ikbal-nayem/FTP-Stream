{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction unionize(record, config) {\n  var _a = config || {},\n      _b = _a.value,\n      valProp = _b === void 0 ? undefined : _b,\n      _c = _a.tag,\n      tagProp = _c === void 0 ? 'tag' : _c;\n\n  var creators = {};\n\n  var _loop_1 = function (tag) {\n    creators[tag] = function (value) {\n      var _a, _b;\n\n      if (value === void 0) {\n        value = {};\n      }\n\n      return valProp ? (_a = {}, _a[tagProp] = tag, _a[valProp] = value, _a) : __assign({}, value, (_b = {}, _b[tagProp] = tag, _b));\n    };\n  };\n\n  for (var tag in record) {\n    _loop_1(tag);\n  }\n\n  var is = {};\n\n  var _loop_2 = function (tag) {\n    is[tag] = function (variant) {\n      return variant[tagProp] === tag;\n    };\n  };\n\n  for (var tag in record) {\n    _loop_2(tag);\n  }\n\n  function evalMatch(variant, cases, defaultCase) {\n    if (defaultCase === void 0) {\n      defaultCase = cases.default;\n    }\n\n    var handler = cases[variant[tagProp]];\n    return handler ? handler(valProp ? variant[valProp] : variant) : defaultCase(variant);\n  }\n\n  var match = function (first, second) {\n    return second ? evalMatch(first, second) : function (variant) {\n      return evalMatch(variant, first);\n    };\n  };\n\n  var identity = function (x) {\n    return x;\n  };\n\n  var transform = function (first, second) {\n    return second ? evalMatch(first, second, identity) : function (variant) {\n      return evalMatch(variant, first, identity);\n    };\n  };\n\n  var as = {};\n\n  var _loop_3 = function (expectedTag) {\n    var _a;\n\n    as[expectedTag] = match((_a = {}, _a[expectedTag] = function (x) {\n      return x;\n    }, _a.default = function (val) {\n      throw new Error(\"Attempted to cast \" + val[tagProp] + \" as \" + expectedTag);\n    }, _a));\n  };\n\n  for (var expectedTag in record) {\n    _loop_3(expectedTag);\n  }\n\n  return Object.assign({\n    is: is,\n    as: as,\n    match: match,\n    transform: transform,\n    _Record: record\n  }, creators);\n}\n\nexports.unionize = unionize;\n/**\n * Creates a pseudo-witness of a given type. That is, it pretends to return a value of\n * type `T` for any `T`, but it's really just returning `undefined`. This white lie\n * allows convenient expression of the value types in the record you pass to `unionize`.\n */\n\nexports.ofType = function () {\n  return undefined;\n};\n\nexports.default = unionize;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction unionize(record, config) {\n    var _a = config || {}, _b = _a.value, valProp = _b === void 0 ? undefined : _b, _c = _a.tag, tagProp = _c === void 0 ? 'tag' : _c;\n    var creators = {};\n    var _loop_1 = function (tag) {\n        creators[tag] = (function (value) {\n            var _a, _b;\n            if (value === void 0) { value = {}; }\n            return valProp ? (_a = {}, _a[tagProp] = tag, _a[valProp] = value, _a) : __assign({}, value, (_b = {}, _b[tagProp] = tag, _b));\n        });\n    };\n    for (var tag in record) {\n        _loop_1(tag);\n    }\n    var is = {};\n    var _loop_2 = function (tag) {\n        is[tag] = (function (variant) { return variant[tagProp] === tag; });\n    };\n    for (var tag in record) {\n        _loop_2(tag);\n    }\n    function evalMatch(variant, cases, defaultCase) {\n        if (defaultCase === void 0) { defaultCase = cases.default; }\n        var handler = cases[variant[tagProp]];\n        return handler ? handler(valProp ? variant[valProp] : variant) : defaultCase(variant);\n    }\n    var match = function (first, second) {\n        return second ? evalMatch(first, second) : function (variant) { return evalMatch(variant, first); };\n    };\n    var identity = function (x) { return x; };\n    var transform = function (first, second) {\n        return second\n            ? evalMatch(first, second, identity)\n            : function (variant) { return evalMatch(variant, first, identity); };\n    };\n    var as = {};\n    var _loop_3 = function (expectedTag) {\n        var _a;\n        as[expectedTag] = match((_a = {},\n            _a[expectedTag] = function (x) { return x; },\n            _a.default = function (val) {\n                throw new Error(\"Attempted to cast \" + val[tagProp] + \" as \" + expectedTag);\n            },\n            _a));\n    };\n    for (var expectedTag in record) {\n        _loop_3(expectedTag);\n    }\n    return Object.assign({\n        is: is,\n        as: as,\n        match: match,\n        transform: transform,\n        _Record: record,\n    }, creators);\n}\nexports.unionize = unionize;\n/**\n * Creates a pseudo-witness of a given type. That is, it pretends to return a value of\n * type `T` for any `T`, but it's really just returning `undefined`. This white lie\n * allows convenient expression of the value types in the record you pass to `unionize`.\n */\nexports.ofType = function () { return undefined; };\nexports.default = unionize;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}
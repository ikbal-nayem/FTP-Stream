{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { useState, useEffect, createElement, Component } from 'react';\nimport invariant from 'invariant';\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\n\nfunction observe(element, callback, options, rootId) {\n  if (options === void 0) {\n    options = {};\n  } // Validate that the element is not being used in another <Observer />\n\n\n  invariant(!INSTANCE_MAP.has(element), \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\", element); // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n\n  if (!options.threshold) options.threshold = 0;\n  var _options = options,\n      root = _options.root,\n      rootMargin = _options.rootMargin,\n      threshold = _options.threshold;\n  if (!element || !callback) return;\n  var observerId = rootMargin ? threshold.toString() + \"_\" + rootMargin : threshold.toString();\n\n  if (root) {\n    observerId = rootId ? rootId + \"_\" + observerId : null;\n  }\n\n  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    visible: false,\n    options: options,\n    observerId: observerId,\n    observer: !observerId ? observerInstance : undefined\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\n\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var observerId = instance.observerId,\n        observer = instance.observer;\n    var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : observer;\n\n    if (observerInstance) {\n      observerInstance.unobserve(element);\n    } // Check if we are still observing any elements with the same threshold.\n\n\n    var itemsLeft = false;\n\n    if (observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (item && item.observerId === observerId && key !== element) {\n          itemsLeft = true;\n        }\n      });\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect();\n      OBSERVER_MAP.delete(observerId);\n    } // Remove reference to element\n\n\n    INSTANCE_MAP.delete(element);\n  }\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling.\n\n    if (instance && intersectionRatio >= 0) {\n      var options = instance.options;\n      var _inView = false;\n\n      if (Array.isArray(options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        _inView = options.threshold.some(function (threshold) {\n          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;\n        });\n      } else if (options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        _inView = instance.visible ? intersectionRatio > options.threshold : intersectionRatio >= options.threshold;\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        _inView = _inView && isIntersecting;\n      }\n\n      instance.visible = _inView;\n      instance.callback(_inView, intersectionRatio);\n    }\n  });\n}\n\nfunction useInView(ref, options) {\n  if (options === void 0) {\n    options = {};\n  } // $FlowFixMe - useState is not exposed in React Flow lib yet\n\n\n  var _React$useState = useState(false),\n      isInView = _React$useState[0],\n      setInView = _React$useState[1]; // $FlowFixMe - useEffect is not exposed in React Flow lib yet\n\n\n  useEffect(function () {\n    if (ref.current) {\n      observe(ref.current, function (inView) {\n        setInView(inView);\n\n        if (inView && options.triggerOnce) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve(ref.current);\n        }\n      }, {\n        threshold: options.threshold,\n        root: options.root,\n        rootMargin: options.rootMargin\n      }, options.rootId);\n    }\n\n    return function () {\n      unobserve(ref.current);\n    };\n  }, [options.threshold, options.root, options.rootMargin, options.rootId]);\n  return isInView;\n}\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\n\n\nvar InView = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n\n  function InView() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      inView: false,\n      intersectionRatio: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"node\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleNode\", function (node) {\n      if (_this.node) unobserve(_this.node);\n      _this.node = node;\n\n      _this.observeNode();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleChange\", function (inView, intersectionRatio) {\n      _this.setState({\n        inView: inView,\n        intersectionRatio: intersectionRatio\n      });\n\n      if (_this.props.onChange) {\n        _this.props.onChange(inView, intersectionRatio);\n      }\n    });\n\n    return _this;\n  }\n\n  var _proto = InView.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.props.hasOwnProperty('render')) {\n        console.warn(\"react-intersection-observer: \\\"render\\\" is deprecated, and should be replaced with \\\"children\\\"\", this.node);\n      }\n\n      invariant(this.node, \"react-intersection-observer: No DOM node found. Make sure you forward \\\"ref\\\" to the root DOM element you want to observe.\");\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold) {\n      unobserve(this.node);\n      this.observeNode();\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node);\n        this.node = null;\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node);\n      this.node = null;\n    }\n  };\n\n  _proto.observeNode = function observeNode() {\n    if (!this.node) return;\n    var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin,\n        rootId = _this$props.rootId;\n    observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    }, rootId);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        render = _this$props2.render,\n        tag = _this$props2.tag,\n        triggerOnce = _this$props2.triggerOnce,\n        threshold = _this$props2.threshold,\n        root = _this$props2.root,\n        rootId = _this$props2.rootId,\n        rootMargin = _this$props2.rootMargin,\n        props = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"render\", \"tag\", \"triggerOnce\", \"threshold\", \"root\", \"rootId\", \"rootMargin\"]);\n\n    var _this$state = this.state,\n        inView = _this$state.inView,\n        intersectionRatio = _this$state.intersectionRatio;\n    var renderMethod = children || render;\n\n    if (typeof renderMethod === 'function') {\n      return renderMethod({\n        inView: inView,\n        intersectionRatio: intersectionRatio,\n        ref: this.handleNode\n      });\n    }\n\n    return createElement(tag || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n\n  return InView;\n}(Component);\n\n_defineProperty(InView, \"defaultProps\", {\n  threshold: 0,\n  triggerOnce: false\n});\n\nexport default InView;\nexport { InView, useInView };","map":{"version":3,"sources":["/home/iku/Dropbox/program/project/samonline/UI/node_modules/react-intersection-observer/dist/react-intersection-observer.esm.js"],"names":["_extends","_objectWithoutPropertiesLoose","_inheritsLoose","_assertThisInitialized","_defineProperty","useState","useEffect","createElement","Component","invariant","INSTANCE_MAP","Map","OBSERVER_MAP","observe","element","callback","options","rootId","has","threshold","_options","root","rootMargin","observerId","toString","observerInstance","get","IntersectionObserver","onChange","set","instance","visible","observer","undefined","unobserve","itemsLeft","forEach","item","key","disconnect","delete","changes","intersection","isIntersecting","intersectionRatio","target","_inView","Array","isArray","some","useInView","ref","_React$useState","isInView","setInView","current","inView","triggerOnce","InView","_React$Component","_this","_len","arguments","length","args","_key","call","apply","concat","node","observeNode","setState","props","_proto","prototype","componentDidMount","process","env","NODE_ENV","hasOwnProperty","console","warn","componentDidUpdate","prevProps","prevState","state","componentWillUnmount","_this$props","handleChange","render","_this$props2","children","tag","_this$state","renderMethod","handleNode"],"mappings":"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","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { useState, useEffect, createElement, Component } from 'react';\nimport invariant from 'invariant';\n\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\n\nfunction observe(element, callback, options, rootId) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // Validate that the element is not being used in another <Observer />\n  invariant(!INSTANCE_MAP.has(element), \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\", element); // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n\n  if (!options.threshold) options.threshold = 0;\n  var _options = options,\n      root = _options.root,\n      rootMargin = _options.rootMargin,\n      threshold = _options.threshold;\n  if (!element || !callback) return;\n  var observerId = rootMargin ? threshold.toString() + \"_\" + rootMargin : threshold.toString();\n\n  if (root) {\n    observerId = rootId ? rootId + \"_\" + observerId : null;\n  }\n\n  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    visible: false,\n    options: options,\n    observerId: observerId,\n    observer: !observerId ? observerInstance : undefined\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var observerId = instance.observerId,\n        observer = instance.observer;\n    var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : observer;\n\n    if (observerInstance) {\n      observerInstance.unobserve(element);\n    } // Check if we are still observing any elements with the same threshold.\n\n\n    var itemsLeft = false;\n\n    if (observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (item && item.observerId === observerId && key !== element) {\n          itemsLeft = true;\n        }\n      });\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect();\n      OBSERVER_MAP.delete(observerId);\n    } // Remove reference to element\n\n\n    INSTANCE_MAP.delete(element);\n  }\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling.\n\n    if (instance && intersectionRatio >= 0) {\n      var options = instance.options;\n      var _inView = false;\n\n      if (Array.isArray(options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        _inView = options.threshold.some(function (threshold) {\n          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;\n        });\n      } else if (options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        _inView = instance.visible ? intersectionRatio > options.threshold : intersectionRatio >= options.threshold;\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        _inView = _inView && isIntersecting;\n      }\n\n      instance.visible = _inView;\n      instance.callback(_inView, intersectionRatio);\n    }\n  });\n}\n\nfunction useInView(ref, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // $FlowFixMe - useState is not exposed in React Flow lib yet\n  var _React$useState = useState(false),\n      isInView = _React$useState[0],\n      setInView = _React$useState[1]; // $FlowFixMe - useEffect is not exposed in React Flow lib yet\n\n\n  useEffect(function () {\n    if (ref.current) {\n      observe(ref.current, function (inView) {\n        setInView(inView);\n\n        if (inView && options.triggerOnce) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve(ref.current);\n        }\n      }, {\n        threshold: options.threshold,\n        root: options.root,\n        rootMargin: options.rootMargin\n      }, options.rootId);\n    }\n\n    return function () {\n      unobserve(ref.current);\n    };\n  }, [options.threshold, options.root, options.rootMargin, options.rootId]);\n  return isInView;\n}\n\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\nvar InView =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n\n  function InView() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      inView: false,\n      intersectionRatio: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"node\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleNode\", function (node) {\n      if (_this.node) unobserve(_this.node);\n      _this.node = node;\n\n      _this.observeNode();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleChange\", function (inView, intersectionRatio) {\n      _this.setState({\n        inView: inView,\n        intersectionRatio: intersectionRatio\n      });\n\n      if (_this.props.onChange) {\n        _this.props.onChange(inView, intersectionRatio);\n      }\n    });\n\n    return _this;\n  }\n\n  var _proto = InView.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.props.hasOwnProperty('render')) {\n        console.warn(\"react-intersection-observer: \\\"render\\\" is deprecated, and should be replaced with \\\"children\\\"\", this.node);\n      }\n\n      invariant(this.node, \"react-intersection-observer: No DOM node found. Make sure you forward \\\"ref\\\" to the root DOM element you want to observe.\");\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold) {\n      unobserve(this.node);\n      this.observeNode();\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node);\n        this.node = null;\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node);\n      this.node = null;\n    }\n  };\n\n  _proto.observeNode = function observeNode() {\n    if (!this.node) return;\n    var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin,\n        rootId = _this$props.rootId;\n    observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    }, rootId);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        render = _this$props2.render,\n        tag = _this$props2.tag,\n        triggerOnce = _this$props2.triggerOnce,\n        threshold = _this$props2.threshold,\n        root = _this$props2.root,\n        rootId = _this$props2.rootId,\n        rootMargin = _this$props2.rootMargin,\n        props = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"render\", \"tag\", \"triggerOnce\", \"threshold\", \"root\", \"rootId\", \"rootMargin\"]);\n\n    var _this$state = this.state,\n        inView = _this$state.inView,\n        intersectionRatio = _this$state.intersectionRatio;\n    var renderMethod = children || render;\n\n    if (typeof renderMethod === 'function') {\n      return renderMethod({\n        inView: inView,\n        intersectionRatio: intersectionRatio,\n        ref: this.handleNode\n      });\n    }\n\n    return createElement(tag || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n\n  return InView;\n}(Component);\n\n_defineProperty(InView, \"defaultProps\", {\n  threshold: 0,\n  triggerOnce: false\n});\n\nexport default InView;\nexport { InView, useInView };\n"]},"metadata":{},"sourceType":"module"}